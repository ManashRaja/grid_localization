#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include <math.h>

using namespace cv;
using namespace std;

int h_th = 60;
int s_th = 60;
int v_th = 30;
int hough_rho = 1;
int hough_theta = 302;
int hough_threshold = 109;
int color_h = 29;
int color_s = 59;
int lowThreshold=100,upperThreshold=100,max_lowThreshold=255,max_upperThreshold=255;
vector<Vec2f> houghLines,lines;


void findInterscetion(float rho1,float theta1,float rho2,float theta2,int rows,int cols,Point *pt)
{
  double a1=cos(theta1);
  double a2=cos(theta2);
  double b1=sin(theta1);
  double b2=sin(theta2);
  pt->x=(rho1*b2-rho2*b1)/(b2*a1-b1*a2);
  pt->y=(rho2*a1-rho1*a2)/(b2*a1-a2*b1);
}

class ImageConverter
{
  ros::NodeHandle nh_;
  image_transport::ImageTransport it_;
  image_transport::Subscriber image_sub_;
  
  
public:
  ImageConverter()
    : it_(nh_)
  {
    
    image_sub_ = it_.subscribe("/ardrone/bottom/image_raw", 1,&ImageConverter::imageCb, this);
cv::namedWindow("hough");
   
    cv::namedWindow("image");

  }

  ~ImageConverter()
  {
    cv::destroyWindow("image");
  }

  void imageCb(const sensor_msgs::ImageConstPtr& msg)
  {
    cv_bridge::CvImagePtr cv_ptr;
    try
    {
      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
    }
    catch (cv_bridge::Exception& e)
    {
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }

// The code starts from here

	Mat orig_hsv,canny_output;

      cvtColor(cv_ptr->image, orig_hsv, CV_BGR2HSV);
Mat choosen(orig_hsv.rows, orig_hsv.cols, CV_8UC1, Scalar(0));
for(int i = 0; i < choosen.rows;i++)
      {
        for(int j = 0; j < choosen.cols;j++)
        {
          //choosen.at<uchar>(i,j) = orig_hsv.at<Vec3b>(i,j)[1];
          if( abs(orig_hsv.at<Vec3b>(i,j)[0] - color_h) < h_th && abs(orig_hsv.at<Vec3b>(i,j)[1] - color_s) < s_th)
          {
            choosen.at<uchar>(i,j) = 255;
          }
        }
      }

blur( choosen, choosen, Size(3,3) );      
      Canny(choosen,canny_output,lowThreshold,upperThreshold);

      createTrackbar( "Rho:", "hough", &hough_rho, 100);
      createTrackbar( "Theta:", "hough", &hough_theta, 1000);   
      createTrackbar( "Threshold:", "hough", &hough_threshold, 200);
      double hough_double_theta =  (double)hough_theta/10000; 
      double hough_double_rho = hough_rho; 
      HoughLines(canny_output, houghLines, hough_double_rho, hough_double_theta, hough_threshold, 0, 0 );

int loop_no = houghLines.size();
       lines.clear();
      for( size_t i = 0; i < loop_no; i++ )
      {


         float rho1 = houghLines[i][0], theta1 = houghLines[i][1];
         float meanRho = rho1;
         float meanTheta = theta1;
         int counter = 1;
         int flag_write = 0;

         //if(lines.size() == 0) ROS_INFO("ya");

        for (int j = 0; j < lines.size();j++)
         {
           float rho2 = lines[j][0], theta2 = lines[j][1];
           if( abs(rho1-rho2) < 200 && abs(theta1 - theta2) < 1 )
           {
            flag_write = 1;
            //lines.back()[0] = (lines.back()[0] + rho2)/2;
            //lines.back()[1] = (lines.back()[1] + theta2)/2;
           }
         }     

         
        
         if(flag_write == 0)
         {
          lines.push_back(Vec2f(meanRho,meanTheta));
          
         }        
          
      }

for(int i = 0; i< lines.size();i++)
      {
        float rho = lines[i][0], theta = lines[i][1];
        Point pt1, pt2;
          double a = cos(theta), b = sin(theta);
          double x0 = a*rho, y0 = b*rho;
          pt1.x = cvRound(x0 + 1000*(-b));
          pt1.y = cvRound(y0 + 1000*(a));
          pt2.x = cvRound(x0 - 1000*(-b));
          pt2.y = cvRound(y0 - 1000*(a));
          line( canny_output, pt1, pt2, Scalar(255), 4, CV_AA);
      }



//----------------------finding intersection of lines------------------------//
      for( size_t i = 0; i < lines.size(); i++ )
        {
          float theta= lines[i][1] ,rho= lines[i][0];
          
          for(size_t j = i+1; j < lines.size(); j++)
          {
            if(fabs(theta-lines[j][1])>0.1)      // if two lines are not parallel we will find their intersection   
            {
                Point intersectionPoint;
                findInterscetion(lines[i][0],lines[i][1],lines[j][0],lines[j][1],cv_ptr->image.rows,cv_ptr->image.cols,&intersectionPoint);
                circle(canny_output,intersectionPoint,10,Scalar(0,200,0));    // a green circle denotes the intersection of two non parallel lines              
                 
            }

          }
         }


      cv::imshow("image",cv_ptr->image);
	cv::imshow("hough",canny_output);
      cv::waitKey(33);
    
   
  }
};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "image_converter");
  ImageConverter ic;
  ros::spin();
  return 0;
}
